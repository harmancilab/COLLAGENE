# Parameter Selection (parameter_selection_example.sh) #
Secure computations by HE-schemes rely on a set of parameters that are used for setting up the keys, encrypting data into ciphertexts, securely evaluating on ciphertexts, and for decrypting results.

These parameters are important as they determine the range of multiplications that can be performed on the data encrypted with the keys generated by *KeyMaker*.

The setting of parameters also roughly determine the precision of the HE operations.

We define the parameters in a file named "ckks.params" in the examples. This file contains 4 lines:
```
16384                       : Polynomial degree modulus
60 40 40 40 40 40 40 60     : Coefficient modulus decomposition bit sizes 
40                          : CKKS "Scale" bit size
40                          : Secret key share noise variance bit size
```

We describe the practical meaning of these parameters below:

## Polynomial Degree Modulus (n)
This parameter determines the number of double precision values we can fit into a ciphertext. Ciphertexts are basic discrete units of encryption where we encrypt an array of floating point numbers.

Given the polynomial degree modulus of 16,384; we can fit exactly 16,384/2=8,192 floating point values into each ciphertext. If you have less values in an array, the remainder of the ciphertext is empty (basically 0's) and are not used (or wasted). 

Increasing this parameter increases the security level of encryption but it decreases the performance and increases the storage space for ciphertexts, i.e., network traffic. It is therefore important to keep this parameter as small as possible while security requirements vs performance is tradeoff is optimized.

## Coefficient modulus decomposition, log(q)

This parameter directly determines the number of multiplications that one can perform. Given the example value above (with 7 values), we can perform 5 consecutive multiplications on each ciphertext before it becomes too "noisy" and cannot be decrypted.

Another importance of the coefficient modulus bit sizes is that it roughly determines the precision of the floating point operations. The first and last entries (60 bits) in the bit size vector is selected as 60 for a good reason and should not be changed.

Decreasing the intermediate values (40 bits) provides a good balance for the precision before and after decimal point of the values. Increasing the intermediate values provide higher accuracy after the decimal point.

Increasing the number of entries in the coefficient modulus bit array enables evaluation of functions with more consecutive multiplications but they decrease the security, dependent on the polynomial degree modulus.

The total number of bit number of bits used in decomposition specifies the coefficient modulus (*q*). In the above example, total bit count of *log(q)* is:

```
60+40+40+40+40+40+40+60=360 bits 
```

*COLLAGENE.sh* can be used (option *-validate_ckks_text_params*) to check if the selection of polynomial degree modulus and coefficient modulus decomposition bit size vector is valid under 128-bit security defined under Homomorphic Encryption Standard white paper (*https://eprint.iacr.org/2019/939.pdf*). 

## CKKS Scale
CKKS scale should be chosen close to the intermediate values (40-bits in the example) of the coefficient modulus bit size vector to make sure scaling of the numbers match the decomposition while we perform multiplication and relinearize ciphertexts.

## Secret Key Share (DSK) Noise Variance Bit Size
This value determines the amount of noise in each DSK generated by KeyMaker. This can be set to a large value such as 40-bits to ensure no partial secret key leakage is possible.